{
  "language": "Solidity",
  "sources": {
    "contracts/BaseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./standards/ERC721.sol\";\nimport \"./libraries/Ownable.sol\";\nimport \"./ENS.sol\";\n\nabstract contract BaseRegistrar is ERC721, Ownable {\n    uint constant public GRACE_PERIOD = 90 days;\n\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\n    event NameRenewed(uint256 indexed id, uint expires);\n\n    // The ENS registry\n    ENS public ens;\n\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address=>bool) public controllers;\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external virtual;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external virtual;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external virtual;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external virtual view returns(uint);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public virtual view returns(bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(uint256 id, address owner, uint duration) external virtual returns(uint);\n\n    function renew(uint256 id, uint duration) external virtual returns(uint);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external virtual;\n}"
    },
    "contracts/standards/ERC721.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"../standards/ERC165.sol\";\nimport \"../libraries/SafeMath.sol\";\nimport \"..//libraries/Address.sol\";\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IERC721.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is IERC721, ERC165 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /*\n     * 0x80ac58cd ===\n     *     bytes4(keccak256('balanceOf(address)')) ^\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\n     *     bytes4(keccak256('approve(address,uint256)')) ^\n     *     bytes4(keccak256('getApproved(uint256)')) ^\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n     */\n\n    constructor() {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner];\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return owner address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public override view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public override {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public override view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function transferFrom(address from, address to, uint256 tokenId) public override {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     *\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n    */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * The call is not executed if the target address is not a contract\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"
    },
    "contracts/ENS.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\n    function setResolver(bytes32 node, address resolver) external virtual;\n    function setOwner(bytes32 node, address owner) external virtual;\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\n    function setApprovalForAll(address operator, bool approved) external virtual;\n    function owner(bytes32 node) external virtual view returns (address);\n    function resolver(bytes32 node) external virtual view returns (address);\n    function ttl(bytes32 node) external virtual view returns (uint64);\n    function recordExists(bytes32 node) external virtual view returns (bool);\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\n}"
    },
    "contracts/standards/ERC165.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"../interfaces/IERC165.sol\";\n\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /**\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor() {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.7.0;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}"
    },
    "contracts/libraries/Address.sol": {
      "content": "// File: openzeppelin-solidity/contracts/utils/Address.sol\n\npragma solidity ^0.7.0;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}"
    },
    "contracts/interfaces/IERC721Receiver.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    external returns (bytes4);\n}"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;\n}"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "pragma solidity ^0.7.0;\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/ETHRegistrarController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ENS.sol\";\nimport \"./interfaces/IERC721.sol\";\nimport \"./libraries/Ownable.sol\";\nimport \"./BaseRegistrar.sol\";\ninterface PriceOracle {\n    /**\n     * @dev Returns the price to register or renew a name.\n     * @param name The name being registered or renewed.\n     * @param expires When the name presently expires (0 if this is a new registration).\n     * @param duration How long the name is being registered or extended for, in seconds.\n     * @return The price of this renewal or registration, in wei.\n     */\n    function price(string calldata name, uint expires, uint duration) external view returns(uint);\n}\n\n// File: @ensdomains/ethregistrar/contracts/StringUtils.sol\n\npragma solidity ^0.7.0;\n\nlibrary StringUtils {\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint) {\n        uint len;\n        uint i = 0;\n        uint bytelength = bytes(s).length;\n        for(len = 0; i < bytelength; len++) {\n            byte b = bytes(s)[i];\n            if(b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n}\n\n// File: @ensdomains/resolver/contracts/Resolver.sol\n\npragma solidity ^0.7.0;\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver{\n    event AddrChanged(bytes32 indexed node, address a);\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\n    event NameChanged(bytes32 indexed node, string name);\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n    function addr(bytes32 node) external view returns (address);\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\n    function contenthash(bytes32 node) external view returns (bytes memory);\n    function dnsrr(bytes32 node) external view returns (bytes memory);\n    function name(bytes32 node) external view returns (string memory);\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n    function setAddr(bytes32 node, address addr) external;\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n    function setName(bytes32 node, string calldata _name) external;\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n    function multihash(bytes32 node) external view returns (bytes memory);\n    function setContent(bytes32 node, bytes32 hash) external;\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n\n// File: @ensdomains/ethregistrar/contracts/ETHRegistrarController.sol\n\npragma solidity ^0.7.0;\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable {\n    using StringUtils for *;\n\n    uint constant public MIN_REGISTRATION_DURATION = 28 days;\n\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private COMMITMENT_CONTROLLER_ID = bytes4(\n        keccak256(\"rentPrice(string,uint256)\") ^\n        keccak256(\"available(string)\") ^\n        keccak256(\"makeCommitment(string,address,bytes32)\") ^\n        keccak256(\"commit(bytes32)\") ^\n        keccak256(\"register(string,address,uint256,bytes32)\") ^\n        keccak256(\"renew(string,uint256)\")\n    );\n\n    bytes4 constant private COMMITMENT_WITH_CONFIG_CONTROLLER_ID = bytes4(\n        keccak256(\"registerWithConfig(string,address,uint256,bytes32,address,address)\") ^\n        keccak256(\"makeCommitmentWithConfig(string,address,bytes32,address,address)\")\n    );\n\n    BaseRegistrar base;\n    PriceOracle prices;\n    uint public minCommitmentAge;\n    uint public maxCommitmentAge;\n\n    mapping(bytes32=>uint) public commitments;\n\n    event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);\n    event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);\n    event NewPriceOracle(address indexed oracle);\n\n    constructor(BaseRegistrar _base, PriceOracle _prices, uint _minCommitmentAge, uint _maxCommitmentAge) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n    }\n\n    function rentPrice(string memory name, uint duration) view public returns(uint) {\n        bytes32 hash = keccak256(bytes(name));\n        // return prices.price(name, base.nameExpires(uint256(hash)), duration);\n        return 0;\n    }\n\n    function valid(string memory name) public pure returns(bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view returns(bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(string memory name, address owner, bytes32 secret) pure public returns(bytes32) {\n        return makeCommitmentWithConfig(name, owner, secret, address(0), address(0));\n    }\n\n    function makeCommitmentWithConfig(string memory name, address owner, bytes32 secret, address resolver, address addr) pure public returns(bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (resolver == address(0) && addr == address(0)) {\n            return keccak256(abi.encodePacked(label, owner, secret));\n        }\n        require(resolver != address(0));\n        return keccak256(abi.encodePacked(label, owner, resolver, addr, secret));\n    }\n\n    function commit(bytes32 commitment) public {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(string calldata name, address owner, uint duration, bytes32 secret) external payable {\n      registerWithConfig(name, owner, duration, secret, address(0), address(0));\n    }\n\n    function registerWithConfig(string memory name, address owner, uint duration, bytes32 secret, address resolver, address addr) public payable {\n        bytes32 commitment = makeCommitmentWithConfig(name, owner, secret, resolver, addr);\n        uint cost = _consumeCommitment(name, duration, commitment);\n\n        bytes32 label = keccak256(bytes(name));\n        uint256 tokenId = uint256(label);\n\n        uint expires;\n        if(resolver != address(0)) {\n            // Set this contract as the (temporary) owner, giving it\n            // permission to set up the resolver.\n            expires = base.register(tokenId, address(this), duration);\n\n            // The nodehash of this label\n            bytes32 nodehash = keccak256(abi.encodePacked(base.baseNode(), label));\n\n            // Set the resolver\n            base.ens().setResolver(nodehash, resolver);\n\n            // Configure the resolver\n            if (addr != address(0)) {\n                Resolver(resolver).setAddr(nodehash, addr);\n            }\n\n            // Now transfer full ownership to the expeceted owner\n            base.reclaim(tokenId, owner);\n            base.transferFrom(address(this), owner, tokenId);\n        } else {\n            require(addr == address(0));\n            expires = base.register(tokenId, owner, duration);\n        }\n\n        emit NameRegistered(name, label, owner, cost, expires);\n\n        // Refund any extra payment\n        if(msg.value > cost) {\n            msg.sender.transfer(msg.value - cost);\n        }\n    }\n\n    function renew(string calldata name, uint duration) external payable {\n        uint cost = rentPrice(name, duration);\n        require(msg.value >= cost);\n\n        bytes32 label = keccak256(bytes(name));\n        uint expires = base.renew(uint256(label), duration);\n\n        if(msg.value > cost) {\n            msg.sender.transfer(msg.value - cost);\n        }\n\n        emit NameRenewed(name, label, cost, expires);\n    }\n\n    function setPriceOracle(PriceOracle _prices) public onlyOwner {\n        prices = _prices;\n        emit NewPriceOracle(address(prices));\n    }\n\n    function setCommitmentAges(uint _minCommitmentAge, uint _maxCommitmentAge) public onlyOwner {\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n    }\n\n    function withdraw() public onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == COMMITMENT_CONTROLLER_ID ||\n               interfaceID == COMMITMENT_WITH_CONFIG_CONTROLLER_ID;\n    }\n\n    function _consumeCommitment(string memory name, uint duration, bytes32 commitment) internal returns (uint256) {\n        // Require a valid commitment\n        require(commitments[commitment] + minCommitmentAge <= block.timestamp);\n\n        // If the commitment is too old, or the name is registered, stop\n        require(commitments[commitment] + maxCommitmentAge > block.timestamp);\n        require(available(name));\n\n        delete(commitments[commitment]);\n\n        uint cost = rentPrice(name, duration);\n        require(duration >= MIN_REGISTRATION_DURATION);\n        require(msg.value >= cost);\n\n        return cost;\n    }\n}"
    },
    "contracts/resolvers/ResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../standards/ERC165.sol\";\nimport \"../interfaces/IVersionableResolver.sol\";\n\nabstract contract ResolverBase is ERC165 {\n    mapping(bytes32 => uint64) public recordVersions;\n\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n\n    /**\n     * Increments the record version associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     */\n    function clearRecords(bytes32 node) public virtual authorised(node) {\n        recordVersions[node]++;\n        emit VersionChanged(node, recordVersions[node]);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IVersionableResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}"
    },
    "contracts/interfaces/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IVersionableResolver {\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n}"
    },
    "contracts/resolvers/AddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ResolverBase.sol\";\nimport \"../interfaces/IAddrResolver.sol\";\nimport \"../interfaces/IAddressResolver.sol\";\n\nabstract contract AddrResolver is\n    IAddrResolver,\n    IAddressResolver,\n    ResolverBase\n{\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(\n        bytes32 node,\n        address a\n    ) external virtual authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(\n        bytes32 node\n    ) public view virtual override returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory a\n    ) public virtual authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n        versionable_addresses[recordVersions[node]][node][coinType] = a;\n    }\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) public view virtual override returns (bytes memory) {\n        return versionable_addresses[recordVersions[node]][node][coinType];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IAddrResolver).interfaceId ||\n            interfaceID == type(IAddressResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function bytesToAddress(\n        bytes memory b\n    ) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}"
    },
    "contracts/interfaces/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(bytes32 node, uint256 coinType)\n        external\n        view\n        returns (bytes memory);\n}"
    },
    "contracts/resolvers/PublicResolver.sol": {
      "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AddrResolver.sol\";\nimport \"../ENS.sol\";\n\n\ncontract PublicResolver is AddrResolver {\n    ENS public ens;\n\n    /**\n     * A mapping of authorisations. An address that is authorised for a name\n     * may make any changes to the name that the owner could, but may not update\n     * the set of authorisations.\n     * (node, owner, caller) => isAuthorised\n     */\n    mapping(bytes32 => mapping(address => mapping(address => bool)))\n        public authorisations;\n\n    event AuthorisationChanged(\n        bytes32 indexed node,\n        address indexed owner,\n        address indexed target,\n        bool isAuthorised\n    );\n\n    constructor(ENS _ens) {\n        ens = _ens;\n    }\n\n    /**\n     * @dev Sets or clears an authorisation.\n     * Authorisations are specific to the caller. Any account can set an authorisation\n     * for any name, but the authorisation that is checked will be that of the\n     * current owner of a name. Thus, transferring a name effectively clears any\n     * existing authorisations, and new authorisations can be set in advance of\n     * an ownership transfer if desired.\n     *\n     * @param node The name to change the authorisation on.\n     * @param target The address that is to be authorised or deauthorised.\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\n     */\n    function setAuthorisation(\n        bytes32 node,\n        address target,\n        bool isAuthorised\n    ) external {\n        authorisations[node][msg.sender][target] = isAuthorised;\n        emit AuthorisationChanged(node, msg.sender, target, isAuthorised);\n    }\n\n    function isAuthorised(bytes32 node) internal override view returns (bool) {\n        address owner = ens.owner(node);\n        return owner == msg.sender || authorisations[node][owner][msg.sender];\n    }\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n}\n"
    },
    "contracts/ENSRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ENS.sol\";\n\n/**\n * The ENS registry contract.\n */\ncontract ENSRegistry is ENS {\n\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping (bytes32 => Record) records;\n    mapping (address => mapping(address => bool)) operators;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 node) {\n        address owner = records[node].owner;\n        require(owner == msg.sender || operators[owner][msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Constructs a new ENS registrar.\n     */\n    constructor() {\n        records[0x0].owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets the record for a node.\n     * @param node The node to update.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }\n\n    /**\n     * @dev Sets the record for a subnode.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     * @param resolver The address of the resolver.\n     * @param ttl The TTL in seconds.\n     */\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }\n\n    /**\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }\n\n    /**\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        _setOwner(subnode, owner);\n        emit NewOwner(node, label, owner);\n        return subnode;\n    }\n\n    /**\n     * @dev Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * @dev Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n\n    /**\n     * @dev Enable or disable approval for a third party (\"operator\") to manage\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\n     * @param operator Address to add to the set of authorized operators.\n     * @param approved True if the operator is approved, false to revoke approval.\n     */\n    function setApprovalForAll(address operator, bool approved) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev Returns the address that owns the specified node.\n     * @param node The specified node.\n     * @return address of the owner.\n     */\n    function owner(bytes32 node) public virtual override view returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address of the resolver for the specified node.\n     * @param node The specified node.\n     * @return address of the resolver.\n     */\n    function resolver(bytes32 node) public virtual override view returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * @dev Returns the TTL of a node, and any records associated with it.\n     * @param node The specified node.\n     * @return ttl of the node.\n     */\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * @dev Returns whether a record has been imported to the registry.\n     * @param node The specified node.\n     * @return Bool if record exists\n     */\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\n        return records[node].owner != address(0x0);\n    }\n\n    /**\n     * @dev Query if an address is an authorized operator for another address.\n     * @param owner The address that owns the records.\n     * @param operator The address that acts on behalf of the owner.\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\n     */\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\n        return operators[owner][operator];\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\n        if(resolver != records[node].resolver) {\n            records[node].resolver = resolver;\n            emit NewResolver(node, resolver);\n        }\n\n        if(ttl != records[node].ttl) {\n            records[node].ttl = ttl;\n            emit NewTTL(node, ttl);\n        }\n    }\n}"
    },
    "contracts/BaseRegistrarImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./BaseRegistrar.sol\";\nimport \"./standards/ERC721.sol\";\n\ncontract BaseRegistrarImplementation is BaseRegistrar {\n    // A map of expiry times\n    mapping(uint256=>uint) expiries;\n\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    constructor(ENS _ens, bytes32 _baseNode) {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become ublock.timestampned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public override view returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external override view returns(uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public override view returns(bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns(uint) {\n      return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n      return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if(_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if(updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns(uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override view returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == ERC721_ID ||\n               interfaceID == RECLAIM_ID;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}